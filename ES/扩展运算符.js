let foo = { ...['a', 'b', 'c'] };
foo // {0: "a", 1: "b", 2: "c"}

// 对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。

// 如果扩展运算符后面不是对象，则会自动将其转为对象。
// 等同于 {...Object(1)}
// { ...1 } // {}
// 上面代码中，扩展运算符后面是整数1，会自动转为数值的包装对象Number{1}。由于该对象没有自身属性，所以返回一个空对象。

// {...'hello'} // {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}
// [...'hello'] // ["h", "e", "l", "l", "o"]


// 对象的扩展运算符等同于使用 Object.assign() 方法。
let aClone = { ...a }; // 浅拷贝
// 等同于
let aClone = Object.assign({}, a);
// Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

// 上面的例子只是拷贝了对象实例的属性(浅拷贝)




拷贝
// 浅拷贝 和 深拷贝是只针对 Object 和 Array 这样的引用数据类型的。
// https://segmentfault.com/a/1190000018874254?utm_source=tag-newest

// 浅拷贝：只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
// 深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

// 浅拷贝：如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。
// 深拷贝：完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。

// 浅拷贝 != 赋值